import { NextRequest, NextResponse } from 'next/server'
import { getSupabaseAdmin } from '@/lib/supabase-admin'
import { Resend } from 'resend'

// Initialize Resend
const resend = new Resend(process.env.RESEND_API_KEY)

// Email sending function with real email delivery
async function sendLetterEmail(emailData: {
  to: string,
  subject: string,
  billId: string,
  sentiment: string,
  letterSubject: string,
  letterMessage: string,
  signatureCount: number,
  targetSignatures: number
}) {
  try {
    // First, log for testing/debugging
    const emailContent = `
=== POLISEE LETTER READY TO SEND ===
TO: ${emailData.to}
SUBJECT: ${emailData.subject}

Bill ID: ${emailData.billId}
Position: ${emailData.sentiment.toUpperCase()}
Signatures: ${emailData.signatureCount}/${emailData.targetSignatures}

LETTER CONTENT:
${emailData.letterSubject}

${emailData.letterMessage}

=== END LETTER ===
`

    console.log('ðŸ“§ EMAIL TO SEND:')
    console.log(emailContent)

    // Send actual email using Resend
    if (process.env.RESEND_API_KEY) {
      console.log('ðŸš€ Sending actual email via Resend...')
      
      const { data, error } = await resend.emails.send({
        from: 'onboarding@resend.dev', // Use Resend's verified test domain
        to: [emailData.to],
        subject: emailData.subject,
        html: `
          <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto; padding: 20px;">
            <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 20px; border-radius: 8px 8px 0 0;">
              <h1 style="margin: 0; font-size: 24px;">ðŸ“¨ Letter Ready to Send</h1>
              <p style="margin: 10px 0 0 0; opacity: 0.9;">Polisee Community Campaign</p>
            </div>
            
            <div style="background: #f8f9fa; padding: 20px; border: 1px solid #e9ecef;">
              <h2 style="color: #333; margin-top: 0;">Campaign Details</h2>
              <div style="background: white; padding: 15px; border-radius: 5px; margin-bottom: 20px;">
                <p><strong>Bill ID:</strong> ${emailData.billId}</p>
                <p><strong>Position:</strong> <span style="color: ${emailData.sentiment === 'support' ? '#28a745' : '#dc3545'}; font-weight: bold;">${emailData.sentiment.toUpperCase()}</span></p>
                <p><strong>Signatures Collected:</strong> ${emailData.signatureCount}/${emailData.targetSignatures}</p>
                <p><strong>Status:</strong> <span style="color: #28a745; font-weight: bold;">âœ… TARGET REACHED - READY TO SEND</span></p>
              </div>
              
              <h3 style="color: #333;">Letter Content</h3>
              <div style="background: white; padding: 20px; border-radius: 5px; border-left: 4px solid #667eea;">
                <h4 style="color: #333; margin-top: 0;">${emailData.letterSubject}</h4>
                <div style="white-space: pre-wrap; line-height: 1.6; color: #555;">
${emailData.letterMessage}
                </div>
              </div>
              
              <div style="margin-top: 20px; padding: 15px; background: #e8f4fd; border-radius: 5px;">
                <p style="margin: 0; color: #0c5aa6; font-weight: bold;">ðŸŽ¯ This letter has reached its signature target and is ready to be sent to representatives!</p>
              </div>
            </div>
            
            <div style="background: #6c757d; color: white; padding: 15px; border-radius: 0 0 8px 8px; text-align: center;">
              <p style="margin: 0; font-size: 14px;">Generated by Polisee - Amplifying Citizen Voices</p>
            </div>
          </div>
        `,
        text: `
POLISEE - Letter Ready to Send

Campaign Details:
- Bill ID: ${emailData.billId}
- Position: ${emailData.sentiment.toUpperCase()}
- Signatures: ${emailData.signatureCount}/${emailData.targetSignatures}
- Status: TARGET REACHED - READY TO SEND

Letter Content:
${emailData.letterSubject}

${emailData.letterMessage}

This letter has reached its signature target and is ready to be sent to representatives!

---
Generated by Polisee - Amplifying Citizen Voices
        `
      })

      if (error) {
        console.error('âŒ Resend error:', error)
        throw new Error(`Failed to send email: ${error.message}`)
      }

      console.log('âœ… Email sent successfully via Resend!')
      console.log('ðŸ“§ Email ID:', data?.id)
      return { success: true, message: 'Email sent via Resend', emailId: data?.id }
      
    } else {
      console.log('âš ï¸ No RESEND_API_KEY found - email logged only')
      return { success: true, message: 'Email logged for testing (no API key)' }
    }
    
  } catch (error) {
    console.error('âŒ Error sending email:', error)
    throw error
  }
}

export async function POST(request: NextRequest) {
  try {
    const { messageId, userName, userEmail, userId, location } = await request.json()

    // Validate required fields
    if (!messageId || !userName) {
      return NextResponse.json(
        { error: 'Missing required fields' },
        { status: 400 }
      )
    }

    const supabase = getSupabaseAdmin()
    
    // Get current user from headers (if authenticated)
    const authHeader = request.headers.get('authorization')
    let currentUserId: string | null = userId || null
    
    if (authHeader?.startsWith('Bearer ')) {
      try {
        const token = authHeader.substring(7)
        const { data: { user } } = await supabase.auth.getUser(token)
        currentUserId = user?.id || null
      } catch (error) {
        console.log('Could not get user from token:', error)
      }
    }

    // Get message details to identify the bill
    const { data: message, error: messageError } = await (supabase as any)
      .from('generated_representative_messages')
      .select('bill_id, sentiment')
      .eq('id', messageId)
      .single()

    if (messageError || !message) {
      return NextResponse.json(
        { error: 'Message not found' },
        { status: 404 }
      )
    }

    // If user is authenticated, check for existing signatures on this bill
    if (currentUserId) {
      // Get all messages for this bill first
      const { data: billMessages, error: billMessagesError } = await (supabase as any)
        .from('generated_representative_messages')
        .select('id')
        .eq('bill_id', message.bill_id)

      if (billMessagesError) {
        console.error('Error fetching bill messages:', billMessagesError)
        // Continue anyway
      } else if (billMessages && billMessages.length > 0) {
        // Remove any existing signatures from this user on this bill
        const messageIds = billMessages.map((msg: any) => msg.id)
        const { error: removeError } = await (supabase as any)
          .from('message_signatures')
          .delete()
          .eq('user_id', currentUserId)
          .in('message_id', messageIds)

        if (removeError) {
          console.error('Error removing existing signatures:', removeError)
          // Continue anyway - we'll handle duplicates with the check below
        } else {
          console.log('âœ… Removed existing signatures for user on bill')
        }
      }
    }

    // Check if this exact signature already exists (fallback for unauthenticated users)
    const { data: existingSignatures, error: checkError } = await (supabase as any)
      .from('message_signatures')
      .select('id')
      .eq('message_id', messageId)
      .eq('user_name', userName)
      .eq('user_email', userEmail || '')

    if (checkError) {
      console.error('Error checking existing signatures:', checkError)
      // Continue anyway
    }

    if (existingSignatures && existingSignatures.length > 0) {
      return NextResponse.json(
        { error: 'You have already signed this message' },
        { status: 400 }
      )
    }

    // Add new signature
    const { data: newSignature, error: signError } = await (supabase as any)
      .from('message_signatures')
      .insert({
        message_id: messageId,
        user_id: currentUserId,
        user_name: userName,
        user_email: userEmail || '',
        location: location || '',
        created_at: new Date().toISOString()
      })
      .select()
      .single()

    if (signError) {
      console.error('Error adding signature:', signError)
      return NextResponse.json(
        { error: 'Failed to add signature' },
        { status: 500 }
      )
    }

    // Get updated signature count
    const { data: signatures, error: countError } = await (supabase as any)
      .from('message_signatures')
      .select('id')
      .eq('message_id', messageId)

    if (countError) {
      console.error('Error getting signature count:', countError)
      return NextResponse.json(
        { error: 'Failed to get signature count' },
        { status: 500 }
      )
    }

    const signatureCount = signatures?.length || 0

    // Update signature analytics
    const { error: analyticsError } = await (supabase as any)
      .from('message_signature_analytics')
      .upsert({
        message_id: messageId,
        total_signatures: signatureCount,
        target_signatures: 1,
        last_signature_at: new Date().toISOString()
      }, {
        onConflict: 'message_id'
      })

    if (analyticsError) {
      console.error('Error updating signature analytics:', analyticsError)
      // Continue - this is not critical
    }

    // Check if target reached and send email
    const targetSignatures = 1 // For testing
    let emailSent = false
    
    if (signatureCount >= targetSignatures) {
      try {
        console.log(`ðŸŽ¯ Target reached! Checking if email needs to be sent for message ${messageId}`)
        console.log(`ðŸ“Š Signature count: ${signatureCount}/${targetSignatures}`)
        
        // Check if email has already been sent for this message
        const { data: messageStatus, error: statusError } = await (supabase as any)
          .from('generated_representative_messages')
          .select('email_sent')
          .eq('id', messageId)
          .single()

        if (statusError) {
          console.log('Could not check email status, will proceed with sending:', statusError)
        }

        if (messageStatus?.email_sent) {
          console.log('âœ… Email already sent for this message')
          emailSent = true
        } else {
          console.log('ðŸ“§ Email not sent yet, sending now...')
          
          // Get the full message details for the email
          const { data: fullMessage, error: messageError } = await (supabase as any)
            .from('generated_representative_messages')
            .select('subject, message, sentiment, bill_id')
            .eq('id', messageId)
            .single()

          if (fullMessage) {
            await sendLetterEmail({
              to: 'benny.yang@gauntletai.com',
              subject: `[POLISEE] ${fullMessage.subject}`,
              billId: fullMessage.bill_id,
              sentiment: fullMessage.sentiment,
              letterSubject: fullMessage.subject,
              letterMessage: fullMessage.message,
              signatureCount: signatureCount,
              targetSignatures: targetSignatures
            })
            console.log('âœ… Email sent successfully!')

            // Try to mark message as sent (will fail if column doesn't exist, but that's OK)
            try {
              await (supabase as any)
                .from('generated_representative_messages')
                .update({
                  email_sent: true,
                  email_sent_at: new Date().toISOString()
                })
                .eq('id', messageId)
              console.log('âœ… Message marked as sent')
            } catch (updateError) {
              console.log('Could not update sent status (column may not exist):', updateError)
            }
            
            emailSent = true
          } else {
            console.log('âŒ Could not get full message details:', messageError)
          }
        }
      } catch (emailError) {
        console.error('âŒ Error sending email:', emailError)
        // Don't fail the signature process if email fails
      }
    } else {
      console.log(`ðŸ“Š Target not reached yet: ${signatureCount}/${targetSignatures}`)
    }

    return NextResponse.json({
      success: true,
      message: 'Signature added successfully',
      signatureCount: signatureCount,
      targetSignatures: targetSignatures,
      targetReached: signatureCount >= targetSignatures,
      emailSent: emailSent,
      signature: newSignature
    })

  } catch (error) {
    console.error('Error in sign-representative-message:', error)
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    )
  }
}

// GET endpoint to retrieve signature count
export async function GET(request: NextRequest) {
  try {
    const url = new URL(request.url)
    const messageId = url.searchParams.get('messageId')

    if (!messageId) {
      return NextResponse.json(
        { error: 'Missing messageId parameter' },
        { status: 400 }
      )
    }

    const supabase = getSupabaseAdmin()

    // Get signature list and count directly
    const { data: signatures, error: sigError } = await (supabase as any)
      .from('message_signatures')
      .select('user_name, created_at')
      .eq('message_id', messageId)
      .order('created_at', { ascending: false })

    if (sigError) {
      console.error('Error fetching signatures:', sigError)
      return NextResponse.json(
        { error: 'Failed to retrieve signatures' },
        { status: 500 }
      )
    }

    const signatureCount = signatures?.length || 0
    const signatureNames = signatures?.map((sig: any) => sig.user_name) || []

    return NextResponse.json({
      success: true,
      messageId,
      signatureCount,
      signatures: signatureNames
    })

  } catch (error) {
    console.error('Error retrieving signatures:', error)
    return NextResponse.json(
      { error: 'Failed to retrieve signatures' },
      { status: 500 }
    )
  }
} 